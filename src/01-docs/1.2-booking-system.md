# 1.2 Booking System – Implementation Notes

This document expands Requirement **1.2 Booking System** into actionable, code-linked guidance. Use it to understand how pickup/destination capture, vehicle type selection, scheduling, fare estimation, and cancellation policies are wired into the NestJS backend.

---

## 1.2.0 Requirement → Implementation map

| Requirement bullet | Implementation |
| --- | --- |
| Pickup location selection (map or address) | `LocationInput` / `LocationPoint` accept both address-only and lat/long payloads (`src/booking/dto/location.input.ts`, `src/booking/models/location-point.model.ts`). |
| Destination selection | `destination` field on `CreateRideBookingInput`, stored as `destinationLocation` on `RideBooking`. |
| Vehicle type selection (Economy, Premium, SUV, etc.) | `VehicleType` enum + column in `RideBooking` (`src/booking/enums/vehicle-type.enum.ts`). |
| Scheduled rides (book in advance) | `scheduledAt` timestamp on `CreateRideBookingInput`; `BookingService` sets `isInstant` and `status` appropriately. |
| Instant booking | Default path when `scheduledAt` is absent/within 5 minutes. |
| Multiple stops support | Optional `stops` array populated with `LocationInput` entries; stored as JSON on the entity. |
| Estimated fare calculation | `BookingService.calculateFare` combines base fare, per-km, per-minute, stop fees, and scheduled surcharges. |
| Estimated arrival time (ETA) | `estimateArrivalTime` derives an ETA from either `scheduledAt` or current time + duration. |
| Ride cancellation (+ policy) | `cancelRide` mutation flips status to `CANCELLED` and tracks penalty using `calculateCancellationPenalty`. |

---

## 1.2.1 Data model

- `src/booking/entities/ride-booking.entity.ts` stores:
  - `passenger`: eager-loaded relation to `User`.
  - `pickupLocation`, `destinationLocation`, `stops`: serialized JSON snapshots of the requested route.
  - `vehicleType`: constrained by the `VehicleType` enum (Economy, Premium, SUV, Executive).
  - Scheduling + lifecycle metadata: `isInstant`, `status`, `scheduledAt`, `estimatedArrival`.
  - Estimation outputs: `estimatedFare`, `estimatedDistanceKm`, `estimatedDurationMinutes`.
  - Cancellation traces: `cancellationPenalty`, `cancellationReason`, `cancellationWindowMinutes`, `cancelledAt`.

The entity lives in its own `ride_bookings` table and is registered through `BookingModule` alongside the `User` repository.

---

## 1.2.2 GraphQL surface area

The resolver (`src/booking/booking.resolver.ts`) exposes four authenticated operations guarded by `JwtAuthGuard`:

1. `createRideBooking(input: CreateRideBookingInput!)`
   - Accepts pickup, destination, optional stops, vehicle type, optional note, optional `scheduledAt`, and optional manual overrides for distance/duration (useful for admin scripts).
   - Returns a `RideBooking` object with computed fare/ETA/cancellation window.
2. `cancelRide(input: CancelRideInput!)`
   - Ensures only the passenger who created the ride can cancel it.
   - Applies cancellation penalties before returning the updated booking.
3. `myRides(status?: RideStatus)`
   - Lists rides for the authenticated passenger, newest first, with an optional status filter (e.g., `SCHEDULED`, `PENDING_DRIVER`).
4. `ride(id: String!)`
   - Fetches a single ride that belongs to the passenger.

Concrete request examples are kept in `src/02-Query/booking.graphql` and mirrored in the README’s “Create Ride Booking” and “List & Cancel Rides” sections.

---

## 1.2.3 Service logic

`src/booking/booking.service.ts` is responsible for:

- **Validation**: Confirms the passenger exists, is active, and not soft-deleted.
- **Instant vs. scheduled logic**: Treats any `scheduledAt` that is >5 minutes in the future as a scheduled ride; everything else is instant.
- **Distance estimation**:
  - If lat/long pairs exist, uses the haversine formula per segment.
  - Otherwise falls back to a heuristic default (3 km per segment) to avoid blocking UI flows.
- **Duration estimation**: Uses an average speed of 32 km/h (configurable constant) unless a manual override is supplied.
- **Fare estimation**:
  - Pricing matrix per vehicle type (`VehicleType` → base/perKm/perMinute).
  - Adds stop fees and a scheduled ride surcharge.
  - Output rounded to two decimals.
- **Cancellation policy**:
  - Instant rides: 5-minute free cancellation window.
  - Scheduled rides: 30-minute window ahead of `scheduledAt`.
  - Penalty = max($5, 15% of estimated fare) when the window is violated.

Any future driver assignment logic can update the same entity (e.g., toggling status to `DRIVER_ASSIGNED`, `IN_PROGRESS`, `COMPLETED`).

---

## 1.2.4 Integration touchpoints

- **Authentication**: The booking resolver calls `this.getUserId(context)` which relies on the JWT payload set by the auth module (same as the `me` query).
- **User entity**: `User.bookings` relation enables quick population of a passenger’s ride history via GraphQL.
- **Documentation**: 
  - README features booking-specific sample queries.
  - This document sits alongside `SETUP.md` and `GRAPHQL_TUTORIAL.md` to keep requirements traceable.

---

## 1.2.5 Testing checklist

1. `signin` to acquire a JWT.
2. Run `createRideBooking` with pickup/destination coordinates—verify `status`, `estimatedFare`, and `estimatedArrival`.
3. Invoke `myRides` with and without the `status` argument.
4. Call `cancelRide` twice—the second call should fail with “Ride can no longer be cancelled”.
5. Create a scheduled ride (`scheduledAt` hours in the future) and confirm:
   - `isInstant` is `false`.
   - `status` = `SCHEDULED`.
   - `cancellationWindowMinutes` = `30`.

---

## 1.2.6 Future enhancements

- Replace heuristic distance/duration logic with Google Maps/Mapbox APIs.
- Introduce surge pricing and promo code adjustments before persisting fare estimates.
- Add driver assignment + navigation hooks once the Driver module ships.
- Emit domain events (`RideCreated`, `RideCancelled`) for analytics and notifications.

Keeping this document updated whenever booking logic evolves will ensure the Requirement §1.2 narrative remains accurate and actionable for downstream teams.


